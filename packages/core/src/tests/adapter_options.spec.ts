import { describe, it, expect } from 'vitest';
import { compile, morphQL } from '../index.js';

describe('Morph Engine - Adapter Options', async () => {
  it('should support named rootGenerated parameter for XML', async () => {
    const query = morphQL`from object to xml(rootGenerated="User") transform set name=name`;
    const transform = await compile(query);
    const result = transform({ name: 'Alice' }) as string;

    expect(result).toContain('<User>');
    expect(result).toContain('<name>Alice</name>');
  });

  it('should support multiple named parameters for XML', async () => {
    const query = morphQL`from object to xml(rootGenerated="Response", attributeNamePrefix="@") transform set value=val set \`@type\`="test"`;
    const transform = await compile(query);

    const result = transform({ val: 123 }) as string;

    expect(result).toContain('<Response');
    expect(result).toContain('type="test"');
    expect(result).toContain('<value>123</value>');
  });

  it('should support multiple positional parameters', async () => {
    const query = morphQL`from object to xml("Root", "Other") transform clone`;
    const transform = await compile(query);
    const result = transform({ a: 1 }) as string;
    expect(result).toContain('<Root>');
  });

  it('should support mixed positional and named parameters (positional first)', async () => {
    // Note: positional parameters are mapped to rootGenerated by our logic
    const query = morphQL`from object to xml("Root", indent=false) transform clone`;
    const transform = await compile(query);
    const result = transform({ a: 1 }) as string;

    expect(result).toContain('<Root>');
    // If indent is false, it should probably be on one line or at least more compact
    // However, our default builder has format: true, so let's just see if it works
    expect(result).toContain('<a>1</a>');
  });

  it('should support numeric literals in options', async () => {
    // Just a dummy test to see if numeric literals are parsed and forwarded
    // We don't have a JSON option that uses numbers yet, but we can verify the compiler output or adapter reception
    const query = morphQL`from object to json(indent=4) transform clone`;
    const transform = await compile(query);
    const result = transform({ a: 1 }) as string;

    // Default JSON adapter uses JSON.stringify(data, null, 2).
    // If forwarded, it might not be used yet unless we update JSON adapter.
    // Let's just verify it compiles and runs.
    expect(JSON.parse(result)).toEqual({ a: 1 });
  });

  it('should forward options to the parse method', async () => {
    // Test XML parser with custom options
    const query = morphQL`
      from xml(ignoreAttributes=true) to object
      transform clone
    `;
    const transform = await compile(query);
    const input = '<root id="123"><name>Test</name></root>';
    const result = transform(input);

    expect(result.root.name).toBe('Test');
    expect(result.root.id).toBeUndefined(); // Because ignoreAttributes=true
  });

  it('should maintain backward compatibility for single positional string', async () => {
    const query = morphQL`from object to xml("Legacy") transform set a=b`;
    const transform = await compile(query);
    const result = transform({ b: 'val' }) as string;
    expect(result).toContain('<Legacy>');
  });
});
